# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoPEC
                A QGIS plugin [Generated by Plugin Builder]

 GeoPEC Linha - Controle de qualidade cartográfica (acurácia posicional
 utilizando feições lineares).
 GeoPEC Linha - Spatial Data Quality (positional accuracy from linear
 feature)


>>  Buffer Duplo implementado de acordo com:
SANTOS, A. P. et al (2015). Controle de qualidade posicional em dados espaciais
utilizando feições lineares. Boletim de Ciências Geodésicas, Curitiba,
v. 21, n. 2, p.233-250, abr-jun, 2015.
Disponível em: <http://revistas.ufpr.br/bcg/article/view/41939/25560>.

  -------------------
        begin             : 2019-06-13
        copyright         : (C) 2019 by Afonso de Paula dos Santos,
                                        Patrícia dos Santos Teixeira
        email             : afonso.santos@ufv.br, patricia.s.teixeira@ufv.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QFileDialog
from qgis.core import *
from osgeo import gdal
# Initialize Qt resources from file resources.py
from .resources import *
import processing
# Import the code for the dialog
from .bufferduplo_dialog import bufferduploDialog
import os.path
import math


class bufferduplo:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
    #################################
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(self.plugin_dir,'i18n','patricia_{}.qm'.format(locale))
        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)
    #################################
                
        # Save reference to the QGIS interface
        self.iface = iface
   
        self.dlg = bufferduploDialog()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('bufferduplo', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        pass
        
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        self.iface.mainWindow().menuBar().removeAction(self.menu.menuAction())
        del self.menu
        # remove the toolbar
        del self.toolbar

    def loadVectors(self):
        """Carrega as camadas vetoriais do projeto do QGIS para o combobox"""
        self.dlg.comboBox.clear()
        self.dlg.comboBox_2.clear()
        layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        vector_layers = []
        for layer in layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                vector_layers.append(layer.name())
        self.dlg.comboBox.addItems(vector_layers)
        self.dlg.comboBox_2.addItems(vector_layers)

    def openVector(self):
        """abre a caixa de dialogo para escolher a layer test"""
        inFile = str(QFileDialog.getOpenFileName(caption="Open shapefile Test",
                                                 filter="Shapefiles (*.shp)")[0])
        #if inFile is not None:
        if (inFile != ""):
            self.iface.addVectorLayer(inFile, str.split(os.path.basename(inFile), ".")[0], "ogr")
            self.loadVectors()

    def saveVector(self):
        """abre a caixa de dialogo para usuario definir o nome e o local do arquivo gerado"""
        outFile = str(QFileDialog.getSaveFileName(caption="Save output as",
                                                  filter="Shapefile (*.shp)")[0])
        self.dlg.lineEdit.setText(outFile)

    def getVectorLayerTest(self):
        """Gets vector layer specified in combo box"""
        layer = None
        layername = self.dlg.comboBox.currentText()
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == layername:
                layer = lyr
                break
        return layer

    def getVectorLayerRef(self):
        """Gets vector layer specified in combo box"""
        layer = None
        layername = self.dlg.comboBox_2.currentText()
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == layername:
                layer = lyr
                break
        return layer

    def setVariables(self):
        """Get and set all variables from UI"""
        self.test = self.getVectorLayerTest()
        self.ref = self.getVectorLayerRef()
        self.bufDist = self.dlg.doubleSpinBox.value()
        self.saida = self.dlg.lineEdit.text()


    def run(self):
        """Run method that performs all the real work"""

        # show the dialog
        self.dlg.show()
        self.dlg.pushButton.clicked.connect(self.openVector)#
        self.dlg.pushButton_2.clicked.connect(self.openVector)#
        self.dlg.pushButton_3.clicked.connect(self.saveVector)#
        self.loadVectors()
        # Run the dialog event loop
        result = self.dlg.exec_()
        # See if OK was pressed
        if result:
            self.setVariables()
            # buffer na linha de referencia
            bufferref = processing.run("native:buffer", {'INPUT': self.ref,
                                                         'DISTANCE': self.bufDist,
                                                         'DISSOLVE': False,
                                                         'END_CAP_STYLE': 0,
                                                         'JOIN_STYLE': 0,
                                                         'OUTPUT': "memory:bufferref"})
            self.bufferref = (bufferref["OUTPUT"])
            #self.iface.addVectorLayer(bufferref["OUTPUT"], str.split(os.path.basename(bufferref["OUTPUT"]), ".")[0], "ogr")
            # buffer na linha de teste
            bufferteste = processing.run("native:buffer", {'INPUT': self.test,
                                                           'DISTANCE': self.bufDist,
                                                           'DISSOLVE': False,
                                                           'END_CAP_STYLE': 0,
                                                           'JOIN_STYLE': 0,
                                                           'OUTPUT': "memory:bufferteste"})
            self.bufferteste = (bufferteste["OUTPUT"])
            #self.iface.addVectorLayer(bufferteste["OUTPUT"], str.split(os.path.basename(bufferteste["OUTPUT"]), ".")[0], "ogr")

            ####################################################################################
            # Área gerada pela operação de buffer em cada linha de teste
            areateste = processing.run("qgis:fieldcalculator", {'INPUT': self.bufferteste,
                                                                'FIELD_NAME': 'areateste',
                                                                'FIELD_TYPE': 0,
                                                                'FIELD_LENGTH': 10,
                                                                'FIELD_PRECISION': 4,
                                                                'NEW_FIELD': True,
                                                                'FORMULA': ' $area ',
                                                                'OUTPUT': "memory:areateste"})
            self.areateste = (areateste["OUTPUT"])
            #self.iface.addVectorLayer(areateste["OUTPUT"], str.split(os.path.basename(areateste["OUTPUT"]), ".")[0], "ogr")

            # Interseção entre os buffers
            intersecao = processing.run("native:intersection", {'INPUT': self.bufferref,
                                                                'OVERLAY': self.bufferteste,
                                                                'INPUT_FIELDS': [],
                                                                'OVERLAY_FIELDS': [],
                                                                'OUTPUT': "memory:intersecao"})
            self.intersecao = (intersecao["OUTPUT"])
            #self.iface.addVectorLayer(intersecao["OUTPUT"],str.split(os.path.basename(intersecao["OUTPUT"]), ".")[0],"ogr")

            # Diferença entre a linha de referência e o interseção
            diferenca = processing.run("native:difference", {
                'INPUT': self.bufferref,
                'OVERLAY': self.intersecao,
                'OUTPUT': "memory:diferenca"})
            self.diferenca = (diferenca["OUTPUT"])
            #self.iface.addVectorLayer(diferenca["OUTPUT"], str.split(os.path.basename(diferenca["OUTPUT"]), ".")[0], "ogr")
         
            # Área AF resultante da "diferença"
            af = processing.run("qgis:fieldcalculator", {'INPUT': self.diferenca,
                                                         'FIELD_NAME': 'af',
                                                         'FIELD_TYPE': 0,
                                                         'FIELD_LENGTH': 10,
                                                         'FIELD_PRECISION': 4,
                                                         'NEW_FIELD': True,
                                                         'FORMULA': ' $area ',
                                                         'OUTPUT': "memory:af"})
            self.af = (af["OUTPUT"])
            #self.iface.addVectorLayer(af["OUTPUT"], str.split(os.path.basename(af["OUTPUT"]), ".")[0], "ogr")


            # União área teste e área referência para cálculo da descrepância
            join = processing.run("qgis:joinattributesbylocation", {'INPUT': self.areateste,
                                                                    'JOIN': self.af,
                                                                    'PREDICATE': [0],
                                                                    'JOIN_FIELDS': [], 'METHOD': 1,
                                                                    'DISCARD_NONMATCHING': False,
                                                                    'PREFIX': '',
                                                                    'OUTPUT': "memory:join"})
            self.join = (join["OUTPUT"])

            # calculo das discrepâncias
            join2 = processing.run("qgis:addfieldtoattributestable", {'INPUT': self.join,
                                                              'FIELD_NAME': 'var',
                                                              'FIELD_TYPE': 1,
                                                              'FIELD_LENGTH': 10,
                                                              'FIELD_PRECISION': 4,
                                                              'OUTPUT': "memory:join2"})
            self.join2 = (join2["OUTPUT"])
            join3 = processing.run("qgis:fieldcalculator", {'INPUT':self.join2,
                                                            'FIELD_NAME':'var',
                                                            'FIELD_TYPE':1,
                                                            'FIELD_LENGTH':10,
                                                            'FIELD_PRECISION':4,
                                                            'NEW_FIELD':False,
                                                            'FORMULA': math.pi * self.bufDist,
                                                            'OUTPUT':"memory:join3"})
            self.join3 = (join3["OUTPUT"])
            #self.iface.addVectorLayer(join3["OUTPUT"], str.split(os.path.basename(join3["OUTPUT"]), ".")[0],"ogr")

            dmi = processing.run("qgis:fieldcalculator", {'INPUT': self.join3,
                                                          'FIELD_NAME': 'dmi',
                                                          'FIELD_TYPE': 0,
                                                          'FIELD_LENGTH': 10,
                                                          'FIELD_PRECISION': 4,
                                                          'NEW_FIELD': True,
                                                          'FORMULA': 'var * af / areateste',
                                                          'OUTPUT': self.saida})
            self.iface.addVectorLayer(self.saida, str.split(os.path.basename(self.saida), ".")[0], "ogr")
        # Do something useful here - delete the line containing pass and
        # substitute with your code.

    # pass
	